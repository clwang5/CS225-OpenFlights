# CS 225 Final Report
## Algorithm Overview
### Dijkstra’s
Our implementation of Dijkstra’s algorithm takes in two node airport IDs (of the starting airport and destination airport) and outputs the shortest path between them. Our Dijkstra's algorithm uses a priority queue and has a time complexity in O(V+E logV) runtime where V is the number of airports and E is the number of edges. The output is a file that displays the source airport, destination airport, and the shortest path between them. It also displays the distance in miles at the end. To test that each algorithm was working as intended, the Dijkstra algorithm includes test cases for empty graphs, undirected graphs, graphs with no path from source to destination, single-heavy weight edges vs many light-weighted edges between source and destination, mostly retrieved from the CS225 resources page. 

### Tarjan's
Our implementation of Tarjan's algorithm utilizes a stack and a DFS traversal, resulting in O(V+E) time complexity where V is the number of airports and E is the number of edges. The Tarjan's algorithm find strongly connected components, which in this case finds all the strongly connected airports. It is strongly connected if there is a path between all pairs of airports. The output of this function is a file that lists all the SCCs with their respective nodes in them. We tested this by creating directed graphs and making sure that the SCCs that are found would be maximal, meaning that every node is a part of the largest SCC possible, and we also tested to ensure that each SCC included the correct nodes. 

### Breadth-First Search
Our breadth-first search algorithm takes in a single starting node and outputs a sequence of nodes in the order it is traversed. The output is a textfile that displays the source airport chosen, then the order each node is processed in the BFS. Our BFS algorithm included a test case that correctly matched the expected traversal of an example graph with a smaller dataset found online.

## Leading Question

The project was successful, as all algorithms were completed. When given two airports, our team's leading question planned on finding the shortest route from one airport to another as a naive method to plan vacations. We answered this by implementing Dijkstra's shortest path algorithm and printing the path of the shortest route and overall distance. We discovered that a big airport like "O'Hare International Airport" is more likely to have a shorter path to other airports in comparison to a small airport to another small airport. We also planned on finding the strongly connected airports which we answered by implementing Tarjan's strongly connected component algorithm. We are able to see which airports are strongly connected, meaning that they all have a path to one another. We discovered some airports that are not strongly connected to any other airports, such as the "Abraham Lincoln Capital Airport". Another intersting discovery was that most of the airports (~95%) in the United States are strongly connected, and after reassessing what strongly connected components means, we found out that it does not necessarily correlate with the popularity of places. Within a strongly connected component, any airport can be accessed for any other airport, and we realized that the Tarjan's result actually makes sense. In the real world, people need to visit varying locations whether it be for work, vacation, or etc, so there is a need for airports to be strongly connected so people can get to where they need to be.
